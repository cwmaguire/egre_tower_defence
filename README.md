# egre_tower_defence
A tower defense game built on egre_arcade, a game engine using the Erlang Graph Rules Engine

My motto for these graph rules engine projects is: infinite CPU,
infinite memory and infinite bandwidtch. That is, this is a proof of
concept and I want to see if it works, at all, rather than a proof
feasibility, where I see if it works well enough to be used.

This is all based on the question: what happens if we make *EVERYTHING*
in a game it's own process? Every object, every state, every rule, etc.
Instead of having a world that "manages" all the objects inside it, all
objects communicate with each other and manage themselves.

```mermaid
flowchart TD
    etd["egre_tower_defence"] --> ea["egre_arcade"]
    ea <--> e["egre"]
    ea --> wa["ws_animator"]
    wa <--> |Web Socket: draw calls| browser(["Browser"])
    browser --> |Web Socket: events| ea
````

The Plan
-----
1. egre_tower_defence (this project) starts up egre_arcade and says "load my rules".
2. egre_arcade starts up egre and creates the graph using the rules from egre_tower_defence
3. egre_arcade starts the Cowboy web server
4. egre_arcade starts listening for websocket connections
5. egre_arcade starts ws_animator
6. ws_animator starts listening for websocket connections
7. User opens a web page which connects to both egre_arcade and ws_animator
8. egre_arcade sends draw calls, generated by rules, to ws_animator
9. Web page sends input events to egre_arcade

Build
-----

    $ rebar3 compile

Run
-----

- Run Erlang shell
  - $ rebar shell
- Open web broswer
- Navigate to http://localhost:8081/
  - goes to index.html
  - webpage should open websocket automatically
  - look in dev console
